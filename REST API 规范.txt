API 端点
    API 端点指的是访问该 API 的 URI，主要由协议、主机名、版本、路径和查询字符串及部分组成，例如
    https://api.example.com/v1/users/me/friends?page=1&per_page=10 。

    整体要求
        简洁
            简洁意味着没有冗余、容易记忆。

            糟糕的：
                https://api.example.com/service/api/search
            好的：
                https://api.example.com/search
        易读
            易读意味着意图明确、容易理解、不容易误用。

            不要轻易使用缩写词，除非该缩写词是计算机领域内的惯例缩写词，又或者是业务领域内的专有名词。
                糟糕的：
                    https://api.example.com/sv/u
                    用 sv 表示 service，u 表示 user 非常不直观。
                好的：
                    https://api.example.com/pv

            使用 API 设计中常用的英文单词，不要使用拼音。
                如果英语能力一般，可以多参考其它优秀的 API 中常用的单词；有时，只参考单个 API 无法确定该使用哪个单词，那就参考多套 API，对比
                后抉择。
                ProgrammableWeb 网站中有收录了很多优秀的 API，可以做参考。

            无大小写混用
                不要使用动词+名词组合的驼峰式命名方式，例如 https://api.example.com/getUser?id=1。
                这是 RPC 风格，在 REST API 风格中，资源用名词来表示，动作用 HTTP 方法来表示，getUser 中的 get 和 HTTP 方法 GET 重复了。
                不要全部大写，不好读，不好理解。
                全部使用小写字母，这是当下主流 API 设计中所采用的风格。
        不暴露服务端架构
            不能暴露服务端所使用的语言、协议或者目录结构等信息。

            糟糕的：
                https://api.example.com/cgi/get_user.php?user=1
            好的：
                https://api.example.com/users/1
        规则统一
            对同一个概念始终使用同一个英文单词来表示。

            名词要么都使用单数、要么都使用复数，建议采用复数。API 端点的组成结构要统一。
                糟糕的：
                    https://api.example.com/friends?id=1
                    https://api.example.com/friend/1/timeline
                好的：
                    https://api.example.com/friends/1
                    https://api.example.com/friends/1/timelines
    协议
        必须使用 HTTPS 协议，理由不赘述。

        糟糕的：
            http://api.example.com/users/1
        好的：
            https://api.example.com/users/1
    主机名
        请使用 api.example.com 这样的二级域名；如果没有二级域名可用，则可以使用三级域名，比如 api.cloud.example.com。
        如果业务特别多且复杂，可以考虑使用 API 专用的域名，比如 googleapis.com，而不是四级域名。
        目前，在路径中加入 /api/ 前缀这样的做法越来越少了，除非有充分的理由，否则不要这么做。

        糟糕的：
            app.rakuten.co.jp/services/api
        还不错的：
            yammer.com/api/v1
        好的：
            api.github.com/v3
            googleapis.com/youtube/v3
    版本
        见下文。
    路径
        使用名词的复数形式
            路径主要用来标识一个资源，所以绝大多数（并非所有）情况下要使用名词，而不是动词。
            本质上，使用单数还是复数并没有差别，但大多数 REST API 使用复数形式，个人建议使用复数形式，不过可以团队投票做最终决定。
            使用名词的复数有一些要注意的地方，比如单复数同形、单复数差异很大以及复数形式词尾不一样等，这个问题只能靠经验和参考字典。
            不论是使用单数还是复数，要至始至终统一。
        不使用空格以及需要百分号编码的字符
            如果使用了这些字符，会导致很难一眼就看出该端点在描述什么。
        使用连字符来连接多个单词
            建议使用连字符（链式）作为多个单次的分隔符，因为连字符是英文单词的标准分隔符，GitHub 和 Google 等大量主流 API 中也都在使用连字符；
            其次推荐下划线（蛇形），不推荐驼峰式。
            最好的办法还是尽可能避免在 URI 中使用多个单词，比如不用 popular-users 而用 users/popular，或者将一部分内容作为查询参数。
    查询字符串
        使用下划线连接查询参数所包含的多个单词
            惯例做法。
        筛选参数
            一般，应该选取精确的参数名称，比如 name 和 age 。
            一般，尽可能少用 LIKE 匹配，如果真的要这么做，应考虑充分利用索引。

            搜索 API
                很多 API 都有专用于进行搜索目的的 API，所以有必要把搜索 API 的端点拿出来说说。

                建议在搜索 API 的端点中添加 search 一词，比如把 search 添加为路径的前缀。虽然 search 是一个动词，用来表示资源不合适，但这
                么做可以清晰的指明该端点的用途，而且这也是一种常见的惯例用法。

                搜索 API 一般只有一个查询参数，建议此时使用查询参数名 q 来体现全文搜索和部分匹配的含义。
        排序参数
            待补充。
        分页参数
            分页参数是一种常见的查询参数，所以有必要单独拿出来说明。

            基于相对位置的分页
                一组惯例分页参数是 page/per_page，page 从 1 开始计数。最常见，灵活性相对较低，但意外情况少，也方便缓存。
                另外一组惯例分页参数是 offset/limit，offset 从 0 开始计数。比较少见，但灵活性相对较高，比如它们可以做到“获取从第 110 条开
                始的 100 条记录”。
                在一套 API 里面尽可能别混用 page/per_page 和 offset/limit，最好始终只用其中一种。
                不论决定使用哪一组惯例分页参数，请直接使用上面列出的参数名称，不要再使用诸如 page_no/page_size 或 start/count 这样的参数
                名称了。

                基于相对位置的分页的优缺点
                    实现简单。
                    对于大规模的数据集，效率低下。因为数据库需要进行 count 和 skip 操作才能确定最终的数据集，比如从 10000000 条数据中选取
                    从第 2000001 条开始的 100 条数据。使用这种方案，在一开始服务刚上线时不会有问题，因为起初数据量比较小，但是随着服务的持续
                    运营，记录的总数目可能会不断增加，此时性能就会越来越差。另外，如果数据经常发生变化，那么返回的结果不可信。在查询的时候如果
                    插入或删除了数据，那么某条数据可能会出现两次或者被漏掉。
                    总体来说，当数据量小且允许结果出现误差的时候，这种方案还是很好用的。

            基于绝对位置的分页
                也被称为基于游标的分页。

                客户端先发送请求，然后服务器端响应请求，返回数据记录的同时还会返回一个游标（Cursor）。在下一次请求中，客户端把这个游标也发送到
                服务器端，这个游标就表示这次所要读取的数据的开始位置。
                游标列一般有两个要求：第一，该列可以排序且排序性能要好；第二，该列的值一般不允许发生变化，如果该列的值允许发生变化，则变化方向不
                能同排序方向冲突，否则返回的结果可能会出现两次或者被漏掉。标列常常是 ID，得到 ID 后服务器端就可以查找该 ID 之前/之后的数据。

                建议在查询字符串中使用 before/after 作为参数名；同时，建议在响应中也使用 before/after 作为游标的键名。
                建议不要使用诸如 cursor、nextId 这些键名。

                基于绝对位置的分页的优缺点
                    实现相对复杂。
                    无法跳转到指定的页，只能一页一页翻。
                    性能好，因为游标对应的字段通常都是索引列，查询速度很快。
                    一致性，添加和删除数据并不影响返回的结果，翻页时同一笔数据也只会被返回一次。
    参数该放在路径中还是查询字符串中
        理论上，凡是可以附加在查询字符串里的参数也都可以附加在路径里，反之依然。所以，在设计 URI 时，必须决定把参数放在查询字符串里还是路径里。
        具体决策依据有以下两点：
            如果参数是用来唯一标识一个资源的，那就放在路径里，否则就放在查询字符串中。
            如果参数可以省略，比如分页参数、排序参数等，那应该放在查询字符串中。
HTTP 方法
    在 REST API 中，HTTP 方法用来表示对该资源进行怎样的操作。具体每种方法用于表示何种操作请自行了解，这里不赘述。

    HTTP 方法覆盖
        少数情况下，客户端无法使用 PUT、PATCH 和 DELETE 方法，比如 HTML 表单只支持支持 GET 和 POST 提交。
        此时，API 服务端应该允许客户端使用 POST 方法来模拟 GET 和 POST 以外的 HTTP 方法，常见的解决方案有两种。
        一种是在 HTTP 请求的 X-HTTP-Method-Override 头部中填入真实的 HTTP 方法来解决，另一种是通过在 _method 参数中填入真实的 HTTP 方
        法来解决。
        推荐使用 X-HTTP-Method-Override 头部，因为 _method 参数这种实现方式有缺陷和局限性，它只能通过
        application/x-www-form-urlencoded 媒体类型来发送，再者，在请求数据中嵌入元数据的做法不值得推荐。
        服务器端实现时，最好同时支持这两种方法，从而提高兼容性，很多框架已经帮我们实现了，直接用即可。
请求
    建议使用 JSON 作为请求数据格式。如果个别 API 需要，可以根据情况使用其他数据格式，此时应在该 API 的文档中进行特别说明。
    不论使用哪种响应数据格式，务必填写 Content-Type 请求头并且在其中放入正确的 MIME 类型。

    数据格式协商
        有的 API 可以返回多种内容，所以客户端和服务器端必须要进行内容协商。这里主要谈和 API 设计关联比较紧密的数据格式（媒体类型）协商，有关内容
        协商的类型和细节，可以参考 MDN。

        数据格式协商的方法主要有三种：
            通过 format 查询参数，比如 ?format=json。
            通过 Accept 请求头，比如 Accept: application/json。
            通过扩展名来指定，比如 https://api.example.com/v1/users.json
        推荐使用前两种方法，但具体使用哪一种，还是说同时支持两种，应由团队商议后做出决定。可以要求客户端每次调用 API 时必须指定响应的数据格式，也
        可以服务器端做好默认值处理。
        不推荐使用第三种方法。
响应
    HTTP 状态码
        应正确并充分地利用 HTTP 状态码来表示响应的类别。

        部分 2XX 状态码
            200
                当使用 GET 方法从服务端成功获取到数据时，应返回 200 状态码。
                建议当使用 PUT 或 PATCH 方法更新了服务端的数据时，应返回 200 状态码；与此同时，应一并返回更新后的数据和最新的 ETag 等信息。
            201
                当使用 POST 方法在服务端成功创建数据时，应返回 201 状态码。
                比如注册了新用户、添加了新的待办事项、上传了图片或者文件等场景。
            202
                当已接收了来自客户端的请求，但处理尚未结束时，应返回 202 状态码。
                一般长用于比较耗时的异步任务，此时可以提前返回 202 给客户端，而不用等任务完成后才返回响应消息。比如文件格式转换等场景。
            204
                建议当使用 DELETE 方法删除了服务端的数据时，应返回 204 状态码；与此同时，不建议同时返回被删除的数据，一般这么做意义不大，且效
                率也不高。如果必须在删除时返回被删除的数据，那么就不能使用 204 状态码，此时应该使用 200 状态码。
        部分 3XX 状态码
            300
                当服务器端难以确定客户端请求的 URI 所能获取的数据的唯一性时，应该返回 300 状态码。
                比如在文件存储类的服务里，对于客户端指定的某个键值存在多个数据，就应该返回该状态码。
            301
                永久重定向，且后续请求的方法可以从 POST 变为 GET。
            302
                临时重定向，且后续请求的方法可以从 POST 变为 GET。
            304
                表示客户端上次获取的数据至今为止没有发生更新。
            307
                临时重定向，且不允许请求方法发生变化。
            308
                永久重定向，且不允许请求方法发生变化。

            API 与 Web 站点不同，虽然也可以使用重定向，但是一般不推荐这么做，因为 API 客户端可能不会去处理重定向；而且，如果知道某个 API 有可
            能会触发重定向操作，应该在该 API 文档中强调，让客户端了解到这种情况的存在。
        部分 4XX 状态码
            待补充。
        部分 5XX 状态码
            500
                表示服务器内部错误。
            501
                表示功能还没实现。
            502
                无效的网关。
            503
                表示服务暂时不可用，一般服务器维护时会返回该状态码。
            504
                网关超时。

        所有状态码的具体含义可以参考：https://httpstatuses.com 。

        如果找不到合适的状态码，可以使用 200、400 和 500 这样以 00 结尾的状态码。
    响应主体的数据格式
        建议使用 JSON 作为响应数据格式；如果个别 API 需要，可以根据情况使用其他数据格式，此时应在该 API 的文档中进行特别说明。
        不论使用哪种响应数据格式，务必返回 Content-Type 响应头且在其中放入正确的 MIME 类型。
        如果使用的是自定义的 MIME 类型，那么就会存在客户端无法识别的问题。此时可以考虑在 Content-Type 中放入标准的 MIME 类型，而通过一个自定
        义的私有头部返回更详细的 MIME 类型，比如 X-XiaoZhu-Media-Type: vnd.xiaozhu.xxx 。
        建议通过返回 X-Content-Type-Options: nosniff 响应头部来关闭客户端的媒体类型推断功能。

        关于 JSONP
            JSONP 是一种规避同源策略的手段，而且还有不少缺陷和安全问题，不适合作为数据交换格式。除非必要，否则不要支持 JSONP。
    错误响应
        HTTP 状态码充其量只能描述错误的类别、概要，在表示和各个具体 API 的业务或者内容相关的错误时显得力不从心，所以除了 HTTP 状态码还要返回详
        细的错误信息。

        返回详细的错误信息的方法有两种：
            使用响应头，例如：
                X-Github-Error-Code: 2013
                X-Github-Error-Message: "Bad ..."
                X-Github-Error-Info: http://docs.example.com/api/v1/auth
            使用响应主体，例如：
                {
                    "error": {
                        "code": 422000000,
                        "message": "验证失败",
                        "details": [
                            {
                                "resource": "Issue",
                                "field": "title",
                                "code": "missing_field"
                            },
                            ...
                        ]
                    }
                }
            建议使用响应主体来存放详细的错误信息，这是事实标准。具体该如何规划错误码和详细的错误信息应由团队商议后决定。
            对于错误码和错误信息，最终形成一份错误码表放到接口文档中，并在规范中强调错误信息随时可能调整，调用方不可将其用于判断或者显示，如果执意
            这么操作，出现问题概不负责。
        发生错误时不要返回 HTML
            即使发生错误，也应该确保错误响应主体的数据格式是指定的数据格式，比如 JSON，而不能返回 HTML。
            一些框架内置支持了停服维护模式，但是在返回 503 状态码的同时，响应主体中包含了默认的 HTML 模版页，这种做法对于 API 调用者来说是不正
            确的。同理，对于提供 API 服务的 Web 服务器来说，比如 Nginx，在发生 404 或者 502 等错误时默认返回的错误页面也是不正确的，应修改
            Nginx 配置，返回指定的数据格式。
        故意返回意义不明确的信息
            有时出于安全或者其他原因，我们需要返回模凌两可的错误码和错误信息。

            比如用户在登录时需要输入邮箱和密码，此时如果登录失败，我们不能返回邮箱不存在，也不能返回密码错误；虽然这些信息对于真正登录失败的用户
            来说是非常友好的，但是也为不怀好意的用户提供了可利用的信息；因此，这种情况下建议只返回一些意义不明确的信息，比如邮箱和密码不匹配。
            类似的情况还有，聊天类在线服务中，不能让被拉黑的用户知道自己被拉黑了，等等。
        定期维护
            API 定期维护时，要返回 503 状态码和完善的错误信息，还要使用 Retry-After 头告知用户维护结束的时间。
            虽然服务端不知道也不能控制客户端会如何利用此时返回的状态码、错误信息和 Retry-After 值，但服务端依然应该返回正确的状态码、完善的错误
            信息，以及 Retry-After 头。
            注意，在预估维护时间时，需要考虑到一些预料之外的事故，所以务必留出充足的时间。
    正确响应
        不要对正确响应的主体进行封装
            糟糕的：
                {
                    "header": {
                        "status": "success",
                        "code": 0
                    },
                    "response": {
                        "friends": [
                            ...
                        ]
                    }
                }
            好的：
                {
                    "friends": [
                        ...
                    ]
                }
            对于正确的响应，不要进行多余的封装，要充分利用 HTTP 协议，只在响应主体中包含有用的数据。
        最外层返回对象还是数组
            建议使用对象来封装数据，而不是数组。
            就算一个接口是用于获取某个列表的，此时，返回数据中除了包含该列表以外，还很可能有其它数据项，比如总数量和游标，所以仍应使用对象。
            通过使用对象进行封装，实现了结构统一，方便客户端处理。API 间统一，API 内也统一（不论是正确响应还是错误响应，返回的都是对象）。
            可以避免 JSON 注入问题，更安全。
            不要因为用 PHP 关联数组用惯了，就习惯性的使用数组。
        面向用例合理的返回数据项
            返回的数据太少，就可能要去访问其他的 API 去继续获取信息，这样的 API 比较难用。例如：
                {
                    "friends": [
                        22322,
                        43452,
                        91928
                    ]
                }
            返回的数据太多，就会产生冗余浪费，解析速度也慢。例如：
                {
                    "friends": [
                        {
                            "id": 22322,
                            "name": "aaaaa",
                            "age": 28,
                            "gender": "male",
                            "avatar": "https://image.example.com/avatar/22322",
                            "createAt": "2020-01-01 00:00:00",
                            "timelines": [
                                {
                                    ...
                                },
                                ...
                            ]
                        }
                    ]
                }
                timelines 很可能就是多余的。
            所以要进行合理的折衷，如何折衷要看用例，也就是看该 API 可能会被调用方如何使用。
        字段协商
            如果一个 API 的用例很难猜测，又或者用例有很多种，很难预测全，此时建议通过 fields 参数来指定要返回的内容，例如：
            ?fields=id,name,create_at 。

            默认情况下，应返回使用频率最高、最重要的数据项；此时如果指定了 fields 参数，则按照该参数的值去选择要获取哪些其他的数据项。
            这里团队有必要讨论一下具体的处理逻辑。但绝对不能默认返回全部数据，这样调用方绝对不会用调用 fields 来进行字段协商了。
        层级化还是扁平化
            层级化
                {
                    "id": 323232322,
                    "message": "Hi!",
                    "sender": {
                        "id": 34567,
                        "name": "Yamada"
                    },
                    "receiver": {
                        "id": 49485,
                        "name": "Mary"
                    }
                }
            扁平化
                {
                    "id": 323232322,
                    "message": "Hi!",
                    "senderId": 34567,
                    "senderName: "Yamada",
                    "receiverId": 49485,
                    "receiverName": "Mary"
                }
            各有优劣，所以没有答案，视情况选取即可。我个人偏好层级化，但一个接口最好只有一层或两层，最多只能有三层，如果超过三层就该考虑一下接口
            设计是否合理。
        是否返回数据总数
            获取数据总数的工作可能比较耗性能，因此必须考量是否真的需要返回数据总数。
            在使用“基于相对位置的分页”时，往往需要获取数据总数。
        是否还有后续数据
            在使用“基于绝对位置的分页”时，往往还需要获取“在当前数据之后是否还有后续数据”的信息，不然客户端就不知道是否还需要继续加载后续数据，也
            就无法判断该显示“继续加载”还是“已到底”等状态。

            服务器端要想知道当前数据之后是否还存在后续数据，并不意味着一定要知道数据总数。比如服务端要返回 20 条数据时，可以试着去获取 21 条数
            据，如果能成功获取 21 条数据，就意味着存在至少 1 条后续数据。此时可以在返回前 20 条数据的同时一并返回后续是否还有数据，还可以从第
            21 条数据中提取出下一次请求的游标。

            建议使用 hasMore 来表示是否还有后续数据，不建议使用 hasNext。因为 hasMore 配合 before/after 更符合语义，容易理解。
    数据字段
        尽可能简洁。
            糟糕的：
                userRegistrationDataTime
            好的：
                registerAt

        建议多使用 API 设计中常用的惯例单词。

        不要轻易使用缩写词，除非该缩写词是计算机领域内的惯例缩写词，又或者是业务领域内的专有名词。
            糟糕的：
                tz
                loc
            好的：
                timezone
                location

        字段对应的数据是一个序列时，需要使用复数，其它情况下使用单数。

        对于由多个单词组成的字段名，统一使用驼峰式，而不是下划线。因为返回的数据整体上是一个对象，而且不论是 PHP 还是 JavaScript 都是用驼峰式来
        连接属性名中的多个单词。
    数据类型
        性别类型
            使用 sex
                一般表示生物学意义上的性别，而生物学上的性别基本上分为男性、女性和不明/其他 3 种，所以一般使用整数（0-不明/其他 1-男性 2-女性）
                来表示。在医疗类的 API 中建议使用 sex。
            使用 gender
                一般表示社会和文化意义上的性别，此时除了男性、女性以外，还可以有很多种性别，所以一般使用字符串（male 表示男性 female 表示女性
                等等）来表示。在社交、电子商务以及其他大部分 API 中建议使用 gender。
        日期类型
            建议统一使用使用 RFC 3339 或者 ISO 8601 作为日期数据的格式，具体使用哪种格式，团队商议后决定。
            建议不要使用时间戳
                时间戳尺寸更小、更容易保存、比较速度也更快，但不直观，不利于开发和调试。不用太担心字符串日期数据的空间浪费和转换时的性能损耗，不
                太可能成为问题或者瓶颈。
            注意，使用字符串日期数据并不影响数据库中使用时间戳。
        大整数
            如果一个整数值超过了 64 位整数所能表示的范围，会被当作浮点数对待从而失去精度，此时可以考虑增加一个 idStr 这样的字段来返回这类数值。
HTTP 协议
    HTTP 协议规定 2XX、3XX 和 4XX 状态的响应必须包含 Date 头部，1XX 和 5XX 状态的响应可以包含 Date 头部。建议所有的响应都应该包含 Date 头
    部。

    缓存
        HTTP 缓存在传统的 Web 中扮演着非常重要的角色，但在 API 设计中却经常被忽视。

        大部分 API 返回的数据是实时的，此时应该通过 HTTP 头部向客户端明确传达"不希望缓存数据"的想法，比如通过 Cache-Control 头部。

        少部分 API 返回的数据是可以被缓存的，比如某时刻的天气预报数据，一旦产生就不太可能发生变更；此时应利用 HTTP 缓存头部来实施缓存。

        HTTP 缓存的内容比较多且复杂，请自行了解，比如参考 MDN。下面列出一些和缓存相关的 HTTP 头部：
            Expires
            Cache-Control
            Date
            Last-Modified
            ETag
            If-Modified-Since
            If-None-Match
            Vary

    私有 HTTP 头部
        当无法找到合适的头部来发送元数据时，可以自定义私有的 HTTP 头部。
        在定义私有 HTTP 头部，建议在最前面添加 X- 前缀，紧接着组织名、服务名或应用名。例如：X-GitHub-Request-Id 。
        关于是否应该使用 X- 前缀，业界存在争议且还没有定论，所以应由团队商议后决定，最重要的是务必统一执行。
        建议 HTTP 头部使用 PascalCase 风格。
版本
    API 发生变化会有哪些影响以及为何要使用版本号来管理 API，这里不赘述，请自行了解。

    版本控制
        推荐遵循 语义化版本控制规范，并在 URI 路径的开头嵌入版本信息，版本信息使用小写字母 v 加上主版本号来表示。例如：
            https://api.example.com/v1/users
        不推荐在查询字符串中加入版本信息，例如：https://api.example.com/users?version=2016-01-01 。
            使用这种风格的版本信息时，version 参数往往是可选的，此时一般会默认使用最新版本或者某个特定的版本，不论哪种方式都不见得是调用者所期
            望的，API 版本应该是必选项。如果非要使用这种方法，默认也应该使用服务器端所支持的最早版本。
        不推荐通过媒体类型或私有头部来指定版本信息。
    版本变更方针
        就算引入了版本控制，也不意味着可以随时对 API 版本进行更新，因为随着 API 版本的更新，不论是发布者的维护成本，还是使用者的应对成本，都会大
        幅增加，所以要尽可能避免频繁的更新 API 版本，能兼容就兼容。具体的兼容方法是经验之谈，这里没办法给出可参考的办法。
    废除旧版本的 API
        考虑到成本问题，同时维护和支持多个版本的 API 是不现实的，此时就需要考虑选择适当时机废除旧版本的 API。

        终止旧版本 API 前
            应事先在 API 的文档里注明返回 410 状态码表示该 API 已停止对外开放。
            我们需要事先公开预计终止的时间等信息并放到 API 文档首页，并想办法持续公告用户，以便用户可以在此之前做好准备。
            通过用户数据分析工具调研客户端版本分布情况，将强制升级带来的影响控制在可接收范围内。
        终止旧版本 API 时
            上线新版 API。
            旧版本 API 统一返回 410 状态码。
            强制客户端进行升级。
            注意：不能在终止旧版本 API 的同时提高所支持的 OS 版本，一般建议在 API 升级之后再废除对旧版本 OS 的支持。
安全
    待补充。
LSUDs 和 SSKDs
    LSUDs（大量未知的开发人员）
        粒度细，面向资源，通用性好（灵活），交互性差
        交互性差在一个功能就可能需要调用多个不同的 API，时间相对长，体验不好，而且调用人员负担比较重。
    SSKDs（小量已知的开发人员）
        粒度粗，面向用例，通用性差（不灵活），交互性好
        灵活性差在很难被复用或者组合。
    如何折衷
        服务层按照 LSUDs 设计和开发通用 API，然后在这些通用 API 前面加一个面向用例的 编排层。
        如果客户端的数量比较多，类型差异比较大，则编排层应该由客户端工程师实现；如果客户端额数量比较少，类型差异比较小，则编排层应该由服务端工程师
        实现，此时服务端工程师应该多考虑一下 API 设计时的复用问题。
HATEOAS 和 REST LEVEL 3
    关于 HATEOAS 和 REST LEVEL 3 的内容请自行了解，这里不做解释说明。

    REST LEVEL 3 的实用性不大，尤其对于面向 LSUDs（大量未知的开发人员） 的公开发布的 API。
    如果是面向 SSUDs（小量已知的开发人员）的内部使用的 API，可以考虑实现 REST LEVEL 3。
    不过个人觉得，就算是内部使用的 API，REST LEVEL 3 的实用性依旧不大，没必要去实现。
