API 端点
    API 端点指的是访问该 API 的 URI，主要由协议、主机名、版本、路径和查询字符串及部分组成，例如 https://api.example.com/v1/users/me/friends?page=1&per_page=10
    
    整体要求
        简洁
            简洁意味着没有冗余、容易记忆。
            
            糟糕的：
                https://api.example.com/service/api/search
            好的：
                https://api.example.com/search
        易读
            易读意味着意图明确、容易理解、不容易误用。
            
            不要轻易使用缩写词，除非该缩写词是计算机领域内的惯例缩写词，又或者是业务领域内的专有名词。
                糟糕的：
                    https://api.example.com/sv/u
                    用 sv 表示 service，u 表示 user 非常不直观。
                好的：
                    https://api.example.com/pv
                
            使用 API 设计中常用的英文单词，不要使用拼音。
                如果英语能力一般，可以多参考其它优秀的 API 中常用的单词；有时，只参考单个 API 无法确定该使用哪个单词，那就参考多个 API，对比后抉择。
                ProgrammableWeb 网站中有收录了很多优秀的 API，可以做参考。
                
            无大小写混用
                不要使用动词+名词组合的驼峰式命名方式，例如 https://api.example.com/getUser?id=1。
                这是 RPC 风格，在 RESTful 风格中，资源用名词来表示，动作用 HTTP 方法来表示，getUser 中的 get 和 HTTP 方法 GET 重复了。
                不要全部大写，不好读，不好理解。
                全部使用小写字母，这是当下主流 API 设计中所采用的风格。 
        不暴露服务端架构
            不能暴露服务端所使用的语言、协议或者目录结构等信息。
            
            糟糕的：
                https://api.example.com/cgi/get_user.php?user=1
            好的：
                https://api.example.com/users/1
        规则统一
            对同一个概念始终使用同一个英文单词来表示。
            
            名词要么都使用单数、要么都使用复数，建议采用复数。API 端点的组成结构要统一。
                糟糕的：
                    https://api.example.com/friends?id=1
                    https://api.example.com/friend/1/timeline
                好的：
                    https://api.example.com/friends/1
                    https://api.example.com/friends/1/timelines
    协议
        必须使用 HTTPS 协议，理由不赘述。
        
        糟糕的：
            http://api.example.com/users/1
        好的：
            https://api.example.com/users/1
    主机名
        请使用 api.example.com 这样的二级域名；如果没有二级域名可用，则可以使用三级域名，比如 api.cloud.example.com。
        如果业务特别多且复杂，可以考虑使用 API 专用的域名，比如 googleapis.com，而不是四级域名。
        目前，在路径中加入 /api/ 前缀这样的做法越来越少了，除非有充分的理由，否则不要这么做。
        
        糟糕的：
            app.rakuten.co.jp/services/api
        还不错的：
            yammer.com/api/v1
        好的：
            api.github.com/v3
            googleapis.com/youtube/v3
    版本
        具体见下文。
    路径
        使用名词的复数形式
            路径主要用来标识一个资源，所以绝大多数（并非所有）情况下要使用名词，而不是动词。
            本质上，使用单数还是复数并没有差别，但大多数 RESTful API 使用复数形式，个人建议使用复数形式，不过可以团队投票做最终决定。
            使用名词的复数有一些要注意的地方，比如单复数同形、单复数差异很大以及复数形式词尾不一样等，这个问题只能靠经验和参考字典。
            不论是使用单数还是复数，要至始至终统一。
        不使用空格以及需要百分号编码的字符
            如果使用了这些字符，会导致很难一眼就看出该端点在描述什么。
        使用连字符来连接多个单词
            建议使用链式法（连字符），因为连字符是英文单词的标准分隔符，GitHub 和 Google 等大量主流 API 中也都在使用连字符；其次推荐蛇形法（下划线），不推荐驼峰法。
            最好的办法还是尽可能避免在 URI 中使用多个单词，比如不用 popular-users 而用 users/popular，或者将一部分内容作为查询参数。
    查询字符串
        使用下滑线连接多个单词
            惯例做法。
        筛选参数
            暂无。
        分页参数
            分页是一种常见的查询参数，所以有必要单独拿出来说明。
            
            基于相对位置的分页
                一组参数是 page/per_page，page 从 1 开始计数。最常见，灵活性相对较低，但意外情况少，也方便缓存。
                另外一组参数是 offset/limit，offset 从 0 开始计数。比较少见，但灵活性相对较高，比如它们可以做到“获取从第 110 条开始的 100 条记录”。
                在一套 API 里面尽可能别混用 page/per_page 和 offset/limit，最好始终只用其中一种。
                不论决定使用哪一组参数，参数名请直接使用上面列出的名称，不要在使用诸如 page_no/page_size 或 start/count 这样的参数名称了。
                
                基于相对位置的分页的优缺点
                    实现简单。
                    对于大规模的数据集，效率低下。因为数据库需要进行 count 和 skip 操作才能确定最终的数据集，比如从 10000000 条数据中选取从第 2000001 条开始的 100 条数据。
                    使用这种方案，在一开始服务刚上线时不会有问题，因为起初数据量比较小，但是随着服务的持续运营，记录的总数目可能会不断增加，此时性能就会越来越差。
                    如果数据经常发生变化，那么结果不可信。在查询的时候如果插入或删除了数据，那么某条数据可能会出现两次或者被漏掉。
                    总体来说，当数据量允许结果出现误差的时候，这种方案还是很好用的。
            
            基于绝对位置的分页
                也被称为基于游标的分页。
                客户端先发送请求，然后服务器端响应请求，返回数据记录的同时还会返回一个游标（Cursor）。在下一次请求中，客户端把这个游标也发送到服务器端，这个游标就表示这次所要读取的数据的开始位置。
                游标常常是 ID 或者时间，得到游标后我们就可以查找该 ID 之前/之后的数据，或者查找该时间之前/之后的数据。
                
                建议在查询字符串中使用 before/after 作为参数名；同时，建议在响应中也使用 before/after 作为游标的键名。
                建议不要使用诸如 cursor、nextId 这些键名。
                
                基于绝对位置的分页的优缺点
                    实现相对复杂。
                    无法跳转到指定的页，只能一页一页翻。
                    性能好，因为游标对应的字段通常都是索引列，查询速度很快。
                    一致性，添加和删除数据并不影响返回的结果，翻页时同一笔数据也只会被返回一次。          
    路径和查询字符串的区别
        理论上，凡是可以附加在查询字符串里的参数也都可以附加在路径里，反之依然。所以，在设计 URI 时，必须决定把参数放在查询字符串里还是路径里。
        具体决策依据有以下两点：
            如果参数是用来唯一标识一个资源的，那就放在路径里，否则适合放在查询字符串中。
            如果参数可以省略，比如分页参数、排序参数等，那应该放在查询字符串中。
    
    搜索类 API
        很多 API 都有专用于进行搜索目的的 API，所以有必要把搜索 API 的端点拿出来说说。
        
        建议在搜索 API 的端点中添加 search 一词，比如把 search 添加为路径的前缀
            虽然 search 是一个动词，用来表示资源不合适，但这么做可以清晰的指明该端点的用途，而且这也是一种常见的惯例用法。
        
        建议使用查询参数 q 来表示全文搜索和部分匹配的项目。
            
HTTP 方法
    在 RESTful 中，HTTP 方法用来表示对该资源进行怎样的操作。具体每种方法用于表示何种操作请自行了解，这里不赘述。
    
    HTTP 方法覆盖
        少数情况下，客户端无法使用 PUT、PATCH 和 DELETE 方法，比如 HTML 表单就支持 GET 和 POST 提交。
        此时，API 服务端应该允许客户端使用 POST 方法来模拟 GET 和 POST 以外的 HTTP 方法，常见的解决方式有两种。
        一种是在 HTTP 请求的 X-HTTP-Method-Override 头部中填入真实的 HTTP 方法来解决，另一种是通过在 _method 参数中填入真的 HTTP 方法来解决。
        推荐使用 X-HTTP-Method-Override 头部，因为 _method 参数这种实现方式有缺陷和局限性，它只能通过 application/x-www-form-urlencoded 媒体类型来发送。
        服务器端实现时，最好同时支持这两种方法，从而提高兼容性，很多框架已经帮我们实现了。
请求

响应
    HTTP 状态码
        应充分利用 HTTP 状态码来表示响应的类别。如果找不到合适的状态码，可以使用 200、400 和 500 这样以 00 结尾的状态码。
    响应主体的数据格式
        绝大多数情况下应使用 JSON 作为响应数据格式；如果个别 API 需要，可以根据情况使用其他数据格式，此时应在该 API 的文档中进行特别说明。
        
        因为没有人一开始就敢肯定所有的 API 都返回 JSON 或者某个其他的数据格式，甚至有的时候 API 可以返回多种数据格式，所以服务端必须要做内容协商处理，这里主要指数据格式（媒体类型）的协商。
        数据格式（媒体类型）的协商的方法主要有两种
            通过 format 查询参数
                比如 ?format=json。
                简单，好实现。
            通过 Accept 请求头
                比如 Accept: application/json。
                正式，更符合 HTTP 协议。
        个人偏好第二种方法，但具体使用哪一种方法，还是说同时支持两种方法，应由团队商议后做出决定。
        可以要求客户端每次调用 API 时必须指定响应数据格式，也可以服务器端做好默认值。
        
        关于 JSONP
            除非必要，否则不支持 JSONP。
            JSONP 是一种规避同源策略的手段，而且还有不少缺陷和安全问题，不适合作为数据交换格式。
    正确响应的主体
        不要对正确响应的主体进行封装
            糟糕的：
                {
                    "header": {
                        "status": "success",
                        "code": 0
                    },
                    "response": {
                        "friends": [
                            ...
                        ]
                    }
                }
            好的：
                {
                    "friends": [
                        ...
                    ]
                }
        对于正确的响应，不要进行多余的封装，要充分利用 HTTP 协议，只在响应主体中包含有用的数据。
    错误响应的主体
        HTTP 状态码充其量只能描述错误的类别、概要，在表示和各个具体 API 的业务或者内容相关的错误时显得力不从心，所以还要返回详细的错误信息。返回详细的错误信息的方法有两种：
            使用响应头，例如：
                X-Github-Error-Code: 2013
                X-Github-Error-Message: "Bad ..."
                X-Github-Error-Info: http://docs.example.com/api/v1/auth
            使用响应主体，例如：
                {
                    "code": 422000000
                    "message": "验证失败"
                    "errors": [
                        {
                            "resource": "Issue",
                            "field": "title",
                            "code": "missing_field"
                        },
                        ...
                    ]
                }
            建议使用响应主题来存放详细的错误信息，这是事实标准，具体该如何规划应由团队商议确定。
        发生错误时不要返回 HTML
            即使发生错误，也应该确保错误响应的主体的数据格式是指定的数据格式，比如 JSON。
    响应主体的结构
        最外层返回对象还是数组
            建议使用对象来封装数据，而不是数组。
            就算一个接口是用于获取某个资源列表的，此时，返回数据中除了包含该资源列表以外，还很可能有其它数据项，比如总数量和游标，所以该使用对象。
            通过使用对象进行封装，实现了结构统一，方便客户端处理。API 间统一，API 内也统一（不论是正确响应还是错误相应，都返回的是对象）。
            可以避免 JSON 注入问题，更安全。
            不要用 PHP 数组用惯了，就习惯性的使用数组。
        面向用例合理的返回数据项
            返回的数据太少，就可能要去访问其他的 API 去继续获取信息，这样的 API 比较难用。例如：
                {
                    "friends": [
                        22322,
                        43452,
                        91928
                    ]
                }
            返回的数据太多，就会产生冗余浪费，解析速度也慢。例如：
                {
                    "friends": [
                        {
                            "id": 22322,
                            "name": "aaaaa",
                            "age": 28,
                            "gender": "male",
                            "avatar": "https://image.example.com/avatar/22322",
                            "create_at": "2020-01-01 00:00:00",
                            "last_login": {
                                "time": "2021-01-01 00:00:00",
                                "ip": "165.165.165.165"
                            },
                            "timelines": [
                                {
                                    ...
                                },
                                ...
                            ]
                        }
                    ]
                }
                timelines 和 last_login 很可能就是多余的。
            所以要进行合理的折中，折中首先要看用例，也就是看该 API 可能会被调用方如何使用。
        字段协商
            示例：?fields=id,name,create_at
            
            如果一个 API 的用例很难猜测，又或者用例有很多种，很难预测全，此时可以考虑让调用方通过 fields 查询参数来选择要获取哪些数据项，我称这种做法为字段协商。
            
            默认情况下，应返回使用频率最高、最重要的数据项；如果指定了 fields 参数，则按照该参数的值去选择要获取哪些数据项。
            这里团队有必要讨论一下具体的处理逻辑。
        层级化还是扁平化
            层级化
                {
                    "id": 323232322,
                    "message": "Hi!",
                    "sender": {
                        "id": 34567,
                        "name": "Yamada"
                    },
                    "receiver": {
                        "id": 49485,
                        "name": "Mary"
                    }
                }
            扁平化
                {
                    "id": 323232322,
                    "message": "Hi!",
                    "sender_id": 34567,
                    "sender_name: "Yamada",
                    "receiver_id": 49485,
                    "receiver_name": "Mary"
                }
            没有答案，应该视情况选取。
        是否返回数据总数
            获取数据的工作可能比较复杂，因此必须仔细确认是否真的需要返回数据总数。
            在使用“基于相对位置的分页”时，往往需要获取数据总数。
        是否还有后续数据
            在使用“基于绝对位置的分页”时，往往还需要获取“在当前数据之后是否还有后续数据”的信息，不然客户端就不知道是否还需要继续加载后续数据，也就无法判断该显示“继续加载”还是“已到底”等状态。
            
            服务端要想的值当前数据之后是否还存在后续数据，并不意味着一定要知道数据总数。比如服务端要返回 20 条数据时，可以试着去获取 21 条数据，如果能成功获取 21 条数据，就意味着存在至少 1 条后续数据。
            此时可以在返回前 20 条数据的同时一并返回后续是否还有数据，还可以从第 21 条数据中提取出下一次请求的游标。
            
            建议统一使用 hasMore 来表示是否还有后续数据，不建议使用 hasNext。hasMore 配合 before/after 更通顺，更容易理解。
    数据字段
        尽可能简洁
            糟糕的：
                userRegistrationDataTime
            好的：
                registeredAt
                
        使用常用的惯例单词。
            
        不要轻易使用缩写词，除非该缩写词是计算机领域内的惯例缩写词，又或者是业务领域内的专有名词。
            糟糕的：
                tz
                loc
            好的：
                timezone
                location
                
        字段对应的数据是一个序列时，需要使用复数，其它情况下使用单数形式。
            
        对于由多个单词组成的字段名，统一使用驼峰式，而不是下划线。因为返回的数据整体上是一个对象，而不论是 PHP 还是 JavaScript，都是用驼峰式来连接属性名中的单词。
    数据类型
        性别类型
            使用 sex
                一般表示生物学意义上的性别，而生物学上的性别基本上分为男性、女性和不明/其他 3 种，所以一般使用整数（0-不明/其他 1-男性 2-女性）来表示。
                在医疗类的 API 中建议使用 sex。
            使用 gender
                一般表示社会和文化意义上的性别，此时除了男性、女性以外，还可以有很多种性别，所以一般使用字符串（male 表示男性 female 表示女性 等等）来表示。
                在社交、电子商务以及其他大部分 API 中建议使用 gender。
        日期类型
            建议统一使用使用 RFC 3339 或者 ISO 8601 作为日期数据的格式，具体使用哪种格式，团队商议后决定，不要使用时间戳。
            虽然时间戳尺寸更小、更容易保存、也更容易进行比较，但不直观，不利于开发调试，忘记那一点空间浪费和转换时消耗的性能吧。
            注意，这并不影响数据库中使用时间戳。
        大整数
            如果一个整数值超过了 64 位整数所能表示的范围，会被当作浮点数对待从而失去精度，此时可以考虑增加一个 idStr 这样的字段来返回这类数值。
    
        
LSUDs 和 SSKDs
    LSUDs（大量未知的开发人员）
        粒度细，面向资源，通用（灵活）性好，交互性差
        交互性差在一个功能就可能需要调用多个不同的 API，时间相对长。
    SSUDs（小量已知的开发人员）
        粒度粗，面向用例，交互性好，通用（灵活）性差
        灵活性差在很难被复用或者组合。
    如何折衷
        服务器端按照 LSUDs 设计和开发通用 API，然后在这些通用 API 前面加一个面向用例的 编排层，用例客户端是最清楚的，所以编排层由客户端工程师实现。
        客户端工程师可以根据客户端的功能或发布周期来修改编排层。
        多客户端应用采取这种方案就很合适。
        
HATEOAS 和 REST LEVEL 3
    关于 HATEOAS 和 REST LEVEL 3 的内容请自行了解，这里不做解释说明。
    
    REST LEVEL 3 的实用性不大，尤其对于面向 LSUDs（大量未知的开发人员） 的公开发布的 API。
    如果是面向 SSUDs（小量已知的开发人员）的内部使用的 API，可以考虑实现 REST LEVEL3。
    不过个人觉得，就算是内部使用的 API，REST LEVEL 3 的实用性依旧不大，没必要去实现。